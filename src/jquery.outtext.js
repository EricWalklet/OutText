!function ($, document, undefined) {

	var PLUGIN_NAME = "OutText",
	
		// Used to find text nodes that contain nothing but whitespace.
		EMPTY_REGEX = /\S/,
		
		defaults = {
			
			/**
 			 * The HREF to apply to links generated by OutText.
			 *
			 * The {t} token, if present, will be replaced by the inner text of the
			 * OutText link.
			 *
			 * @property href_template
			 * @type String
			 */
			href_template: "#",
			
			/**
			 * The frequency with which OutText will generate a link.
			 *
			 * This is a value from 0 to 1. A value of 0 will produce no
			 * links, whereas a value of 1 will change every possible word
			 * into a link.
			 *
			 * @property frequency
			 * @type Number
			 */
			frequency: 0.1,
			
			/**
			 * An array of element names that OutText will ignore when traversing
			 * the page, i.e. regardless of child text content, no links will be
			 * generated within elements of these types.
			 *
			 * This will get translated into a map for performance reasons. Accepting
			 * a map directly would probably save some code and processing time, but
			 * it'd be less convenient for any clients using the plugin.
			 *
			 * @property excluded_elements
			 * @type String[]
			 */
			excluded_elements: ["button", "a"],
			
			/**
			 * An array of case-insensitive words that, when encountered, will always
			 * force creation of an OutText link, regardless of the configured
			 * frequency.
			 *
			 * See above note about performance vs. ease of use.
			 *
			 * @property forced_words
			 * @type String[]
			 */
			forced_words: []
		};

	function OutText (element, options) {

		var // Used to find leading and trailing punctuation in potential link text
			PUNCT_REGEX = /\W/,
			
			// An empty link element that will be cloned when creating OutText links
			LINK_TEMPLATE = document.createElement("a"),

			config = $.extend({}, defaults, options),
			frequency = config.frequency,
			href_template = config.href_template,

			// Convert the list of excluded elements into a map, and use it when
			// traversing the DOM to look for text nodes.
			textNodes = getTextNodes(element, mapify(config.excluded_elements)),
			
			// Convert the list of forced words into a map, and use it when processing
			// the complete list of text nodes.
			forcedWords = mapify(config.forced_words),

			textNode, processedContent, words, word, wordLength, firstChar, lastChar, link, startIndex, endIndex,
			x, y, yl;
		
		// Process each text node separately.
		for (x = 0, xl = textNodes.length; x < xl; x++) {
			textNode = $(textNodes[x]);
		
			// Split the content of the text node into words.
			words = textNode.text().split(" ");
			processedContent = [];
			
			// Process each word in the text node.
			for (y = 0, yl = words.length; y < yl; y++) {
				word = words[y];
			
				// Generate a random number.  If the random number is less than the
				// configured frequency, turn the word into a link.
				if (forcedWords[word.toUpperCase()] || (Math.random() < frequency)) {
				
					// Determine when any leading punctuation ends and when the actual word
					// content begins.
					startIndex = -1;
					firstChar = word.substr(startIndex + 1, 1);
					while (PUNCT_REGEX.test(firstChar)) {
						firstChar = word.substr(++startIndex, 1);
					}
					
					// If we found any leading punctuation, extract them from the word, and
					// give them their own text node.
					if (startIndex > -1) {
						processedContent.push(createTextNode(word.substr(0, startIndex)));
						word = word.substr(startIndex);
					}
					
					// Determine when the actual word content ends and when any trailing
					// punctuation begins.
					wordLength = word.length;
					endIndex = wordLength;
					lastChar = word.substr(endIndex - 1, 1);
					while (PUNCT_REGEX.test(lastChar)) {
						lastChar = word.substr(--endIndex - 1, 1);
					}
					
					// If we found any trailing punctuation, extract them from the word. We'll
					// give them their own text node eventually, after the word link is processed.
					if (endIndex < wordLength) {
						lastChar = word.substr(endIndex);
						word = word.substr(0, endIndex);
					} else {
						lastChar = null;
					}

					// Create the link, using the HREF template to create the target.
					word = MAGIC_WORDS[word] || word;
					link = LINK_TEMPLATE.cloneNode();
					link.href = MAGIC_HREFS[word.toUpperCase()] || href_template.replace(/{t}/g, word);
					link.innerHTML = word;

					// Add the link to the collection of processed content.
					processedContent.push(link);
					
					// If we found trailing punctuation earlier, add it now.
					if (lastChar) {
						processedContent.push(createTextNode(lastChar));
					}

				} else {
				
					// Create a new text node containing only the word, and add it to
					// the collection of processed content.
					processedContent.push(createTextNode(word));
				}
				
				// This process removes the spaces between the words, so add a new
				// text node that contains a space.
				processedContent.push(createTextNode(" "));
			}
			
			// The last node in the collection is an unneeded space character.
			processedContent.pop();
			
			// Replace the original text node with the new set of nodes that was
			// just created after processing the text content.
			$(textNode).replaceWith(processedContent);
		}
	}
	
	/**
	 * Create a simple map from an array of strings.
	 *
	 * @method mapify
	 * @param {String[]} arr the seed array
	 * @return a simple map with a key set that originated from the given array
	 * @type Object
	 */
	function mapify (arr) {
		var map = {},
			arrElement,
			x, xl;

		for (x = 0, xl = arr.length; x < xl; x++) {
			map[arr[x].toUpperCase()] = true;
		}

		return map;
	}
	
	/**
	 * Creates a new text node with the given contents.
	 *
	 * @method createTextNode
	 * @param {String} text the contents of the new text node
	 * @return the new text node
	 * @type HTMLElement
	 */
	function createTextNode (text) {
		return document.createTextNode(text);
	}
	
	/**
	 * Recursively retrieves all text nodes within the given root element.
	 *
	 * @method getTextNodes
	 * @param {HTMLElement} root the element to use as the root
	 * @param {Object} excludedElements map of node names that will be ignored
	 *		when searching for text nodes
	 * @return all text nodes for which the given root is an ancestor
	 * @type HTMLElement[]
	 */
	function getTextNodes (root, excludedElements) {

		var text = [],
			rootChildren, rootChild,
			x, xl;

		// Once we hit a text node, add it to the collection...
		if (root.nodeType === 3) {
		
			// ... unless it contains nothing but whitespace.
			if (EMPTY_REGEX.test(root.nodeValue)) {
				text.push(root);
			}

		} else {

			// If the root isn't a text node, check each of its
			// children for text nodes.
			rootChildren = root.childNodes;
			for (x = 0, xl = rootChildren.length; x < xl; x++) {
				rootChild = rootChildren[x];
				
				// Ignore any nodes that are in the list of excluded elements.
				if (!excludedElements[rootChild.nodeName]) {
					text = text.concat(getTextNodes(rootChildren[x], excludedElements));
				}
			}
		}

		return text;
	}
	
	// Allow OutText to be used when providing a selector.
	$.fn[PLUGIN_NAME] = function (options) {
		return this.each(function () {
			var pluginKey = "plugin_".concat(PLUGIN_NAME);
			if (!$.data(this, pluginKey)) {
                $.data(this, pluginKey, new OutText(this, options));
            }
		});
	};
	
	// Allow OutText to be used without providing a selector.
	$[PLUGIN_NAME] = function (options) {
		var pluginKey = "plugin_".concat(PLUGIN_NAME),
			el = document.body;
		if (!$.data(el, pluginKey)) {
			$.data(el, pluginKey, new OutText(el, options));
		}
	};
	
	// But wait... There's more...
	var MAGIC_WORDS = {/* Uncomment for silliness.
		
		// Always bet on red.
		"black": "red",
		"Black": "Red",
		"BLACK": "RED",
		
		// I yam what I yam.
		"Eric": "Noob",
		
		// You guys have bigger backbones than me. I could never jump unless I was pushed.
		"skydiving": "AAAAAAaaaaaaaaAAAAAAAaaaaaaaAAAAAAAH!!!",
		"Skydiving": "AAAAAAaaaaaaaaAAAAAAAaaaaaaaAAAAAAAH!!!",
		"SKYDIVING": "AAAAAAaaaaaaaaAAAAAAAaaaaaaaAAAAAAAH!!!"
	*/},
	
		MAGIC_HREFS = {/* Uncomment for additional silliness.
		"RED": "http://www.50onred.com",
		"NOOB": "http://www.linkedin.com/pub/eric-walklet/36/b08/2a8",
		"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAH!!!": "http://amzn.to/1hyIEmW"
	*/};
	
}(jQuery, document);